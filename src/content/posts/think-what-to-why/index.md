---
title: 무엇(What)에서 왜(Why)로 API 설계에서 배운 관점 전환
published: 2025-07-11
description: ""
image: "./why.png"
tags: [ "GraphQL"]
category: GraphQL
draft: true
---


## 들어가며

이 글은 REST API와 GraphQL의 성능이나 기술적 장단점을 설명하려는 것이 아닙니다.
0→1 프로젝트를 진행하면서 미숙한 실력으로 API를 구성했던 제 경험, 그리고 그 과정에서 GraphQL을 도입하며 관점이 (What에서 Why로) 어떻게 바뀌었는지에 대한 개인적인 성찰을 담고자 합니다.

제 경험이 아직 제한적이기에, 숙련된 개발자라면 여러 기술을 통해 동일한 가치를 충분히 만들어낼 수 있을 것입니다. 그래서 이 글은 어떤 기술을 선택했는지보다, 그 과정에서 제가 얻은 사고의 변화와 인사이트에 더 집중하고자 합니다.

기술을 먼저 보고 요구사항을 해석하면 사용자 목표에서 점점 멀어질 수 있다에 대한 인사이트입니다.
제가 좁은 관점에서 보는 부분은 양해해 주시면 감사하겠습니다.

## What으로 해석한 API

요구사항 시나리오를 받았습니다.
유저의요구사항 : 이번 주, 특정 지점에서 예약 가능한 모든 클래스와 타임슬롯을 한 번에 보고 싶다.

처음 요구사항을 받고 드는 생각은 이걸 어떻게 구현하지? 라는 생각이 먼저 듭니다.
유저 케이스를 보면,날짜 -> 특정 지점 -> 예약가능한 클래스 -> ->타임슬롯
타임슬롯이 나오기 위해선 특정 지점과 날짜가 선행되어야 하므로 계층적 구조가 자연스레 떠오릅니다.

그래서 초기 설계는 아래처럼 계층 구조를 따라 만들었습니다.

```
GET api/stores
GET api/stores/:storeID/classes
GET api/classes/:classesId/timeslots
GET api/timeslots/:timeslotId
GET api/stores/:storeId/classes/:classId/timeslots?date={date}

```

사용자의 요구사항엔 잘 반영했다고 생각했습니다.
그런데 정말 이게 사용자의 본질을 담고 있는 건지 확신이 들지 않았습니다.

• REST 방식(What):
/stores/:storeId/classes/:classId/timeslots?date= 계층 구조로 호출 → 1. 지점을 먼저 선택 2. 선택한 지점의 클래스를 조회 3. 클래스별 타임슬롯 조회

여기서 문제는 사용자가 원하는 목표(예약 가능 시간 확인)를 달성하기 위해, 프론트가 여러 엔드포인트를 반복 호출하고 데이터를 조합해야 한다는 것입니다.

다수의 엔드포인트 호출은 전송적 제약 때문에 생긴 구조(What)가 괜찮을까 였습니다.
이건 기술적 편의로 사용자의 본질을 흐트릴 수 있지 않을까 였습니다.

사용자는 “이번 주에 내가 예약할 수 있는 시간과 장소를 한눈에 보고 싶다”입니다. 즉 사용자의 목표는 ‘예약 가능한 시간과 지점 확인’이지, 이를 몇번의 추가적인 네트워크 연산을 통해 사용자가 **한번에** 전체 시간표 보기 라는 목표를 달성하지 못하고 프론트에서 데이터를 합치며 지연을 발생시킵니다.

제가 말하는 지연은 다음과 같은 코드의 호출입니다. 


<실제 지연 호출 넣기 >

## Graphql

GraphQL 을 도입하고 나서 가장 크게 느낀점은 사용자의 Why를 기준으로 설계하면서 graphql이란 스키마 기술(What) 순으로 사고가 된

단일 쿼리로,
• 이번 주 기준
• 예약 가능한 클래스와 타임슬롯
• 선택 가능한 지점 정보

모든 데이터를 한 번에 가져올 수 있습니다.

- GraphQL 방식(What):
  단일 쿼리에서 date 기준으로 가능한 지점과 클래스, 타임슬롯을 모두 조회 가능

이 유저의 요구 사항에는 내가 예약할 수 있는 시간과 장소를 한눈에
보고싶다 입니다

시나리오 2: 기획 변경 – 예약 가능한 타임슬롯만 노출

    •	기존 REST 문제
    •	기존 구조: /timeslots를 가져오고 프론트에서 필터링 필요 → 불필요한 데이터 전송.
    •	만약 ‘예약 가능한 것만’ 노출하라는 기획이 추가되면, 프론트/백엔드 양쪽 모두 수정 필요.
    •	GraphQL 가능 시나리오
    •	서버에서 바로 필터링 가능:

```tsx

query {
  store(id: 1) {
    classes {
      name
      timeslots(date: "2025-01-15", onlyAvailable: true) {
        startTime
      }
    }
  }
}

```